<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css">
    <title>음성 분석</title>
</head>
<script type="module">
  import { VoiceProcessor } from "./voice-processor.js?v=2";
  import { setQuestionText, setDescriptionText, setTimer, setRecordButtonState } from "./voice-ui.js";

  // ---------------------------
  // API helper
  // ---------------------------
const API_BASE = "https://rhythme-server-357918245340.asia-northeast3.run.app";

window.copyShareLink = async function () {
  const u = new URL(location.href);
  u.searchParams.delete("sid");
  const shareUrl = u.toString();
  try { await navigator.clipboard.writeText(shareUrl); }
  catch { prompt("복사해서 보내:", shareUrl); }
};

function apiUrl(path) {
  const base = API_BASE.endsWith("/") ? API_BASE : API_BASE + "/";
  const clean = String(path || "").replace(/^\//, "");
  return new URL(clean, base).toString();
}

function showErrorModal(title, message, detail) {
  // detail은 개발용(짧게). URL/민감정보는 넣지 말 것.
  const id = "rhythmeErrorModal";
  let modal = document.getElementById(id);

  if (!modal) {
    modal = document.createElement("div");
    modal.id = id;
    modal.style.cssText = `
      position:fixed; inset:0; z-index:999999;
      background:rgba(0,0,0,.55);
      display:flex; align-items:center; justify-content:center;
      padding:18px;
    `;
    modal.innerHTML = `
      <div style="
        width:min(520px, 92vw);
        background:#111827; color:#fff;
        border:1px solid rgba(255,255,255,.12);
        border-radius:16px; padding:16px;
        box-shadow:0 18px 60px rgba(0,0,0,.45);
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      ">
        <div style="font-weight:800; font-size:16px; margin-bottom:8px;" id="rhErrTitle"></div>
        <div style="font-size:14px; line-height:1.4; opacity:.95;" id="rhErrMsg"></div>
        <pre style="
          margin-top:10px; padding:10px;
          background:rgba(255,255,255,.06);
          border-radius:12px; overflow:auto;
          font-size:12px; opacity:.9; display:none;
        " id="rhErrDetail"></pre>
        <div style="display:flex; justify-content:flex-end; margin-top:12px;">
          <button id="rhErrClose" style="
            padding:10px 14px; border-radius:12px;
            border:1px solid rgba(255,255,255,.16);
            background:transparent; color:#fff; font-weight:700;
            cursor:pointer;
          ">확인</button>
        </div>
      </div>
    `;
    modal.addEventListener("click", (e) => {
      if (e.target === modal) modal.remove();
    });
    document.body.appendChild(modal);
    modal.querySelector("#rhErrClose").onclick = () => modal.remove();
  }

  modal.querySelector("#rhErrTitle").textContent = title || "오류";
  modal.querySelector("#rhErrMsg").textContent = message || "오류가 발생했습니다.";

  const d = modal.querySelector("#rhErrDetail");
  if (detail) {
    d.style.display = "block";
    d.textContent = detail;
  } else {
    d.style.display = "none";
    d.textContent = "";
  }
}


// ✅ 자동 로그 수집(사용자 액션 0)
async function logClientError(err, context = {}) {
  const sid =
    new URLSearchParams(location.search).get("sid") ||
    localStorage.getItem("SESSION_ID");

  const payload = {
    session_id: sid,
    where: "voice_test",
    message: String(err?.message || err),
    name: err?.name,
    stack: err?.stack,
    ua: navigator.userAgent,
    href: location.href,
    ...context,
  };

  try {
    await fetch(apiUrl("/client-log"), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      keepalive: true, // ✅ 모바일/인앱에서 페이지 전환 중에도 최대한 보내기
    });
  } catch (_) {
    // 실패해도 사용자 UX는 방해하지 않음
    console.warn("client-log failed", payload);
  }
}

// ✅ 전역 에러도 자동 수집
window.addEventListener("error", (e) => {
  logClientError(e.error || e.message, {
    type: "window.error",
    filename: e.filename,
    lineno: e.lineno,
    colno: e.colno,
  });
});

window.addEventListener("unhandledrejection", (e) => {
  logClientError(e.reason, { type: "unhandledrejection" });
});


  // ---------------------------
  // Session helper (단일 진실)
  // ---------------------------
function getSid() {
  const urlSid = new URLSearchParams(location.search).get("sid");
  const storeSid = localStorage.getItem("SESSION_ID");
  const winSid = window.SESSION_ID;

  const sid = urlSid || storeSid || winSid;

  if (!sid) {
    if (typeof window.showModal === "function") {
      window.showModal("세션이 없습니다. 처음부터 다시 진행해주세요.");
      setTimeout(() => location.href = "./index.html", 300);
    } else {
      alert("세션이 없습니다. 처음부터 다시 진행해주세요.");
      location.href = "./index.html";
    }
    return null;
  }

  window.SESSION_ID = sid;
  localStorage.setItem("SESSION_ID", sid);
  return sid;
}


  // ---------------------------
  // Progress (테스트 이어하기/초기화)
  // ---------------------------
  const ALLOW_RESUME = false;          // 운영모드: false 추천(항상 처음부터)
  const MAX_IDLE_MS = 15 * 60 * 1000;  // resume 허용 시, 15분 이상 비면 새로

  function progressKey(sid) { return `rh_progress_${sid}`; }
  function idleKey(sid) { return `rh_last_${sid}`; }

  function loadProgress(sid) {
    try { return JSON.parse(localStorage.getItem(progressKey(sid)) || "null"); }
    catch { return null; }
  }
  function saveProgress(sid, data) {
    localStorage.setItem(progressKey(sid), JSON.stringify(data));
    localStorage.setItem(idleKey(sid), String(Date.now()));
  }
  function clearProgress(sid) {
    localStorage.removeItem(progressKey(sid));
    localStorage.removeItem(idleKey(sid));
  }

  // ✅ 새 sid 만들지 말고 "현재 sid로 초기화"만
function resetRun(sid) {
  clearProgress(sid);
  stageIdx = 0;
  saveProgress(sid, { stageIdx: 0, startedAt: Date.now() });
  return sid;
}
  
  function bootstrapRun() {
  const sid = getSid();
  if (!sid) return null;

  if (!ALLOW_RESUME) {
    return resetRun(sid);
  }

  const last = Number(localStorage.getItem(idleKey(sid)) || "0");
  const idle = Date.now() - last;
  const p = loadProgress(sid);

  if (!p || idle > MAX_IDLE_MS) {
    return resetRun(sid);
  }

  stageIdx = p.stageIdx ?? 0;
  localStorage.setItem(idleKey(sid), String(Date.now()));
  return sid;
}

function hash32(str) {
  // 가벼운 32bit 해시 (deterministic)
  let h = 2166136261;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function getVoiceVersion() {
  // 1) 이미 배정된 버전이 있으면 그걸 고정 사용
  const saved = localStorage.getItem("rhythmi_voice_version");
  if (saved === "v1.1" || saved === "v1.2") return saved;

  // 2) 없으면 SESSION_ID로 50:50 고정 배정
  const sid = localStorage.getItem("SESSION_ID");
  if (!sid) return "v1.1"; // sid 없으면 안전하게 기본값

  const v = (hash32(sid) % 2 === 0) ? "v1.1" : "v1.2";
  localStorage.setItem("rhythmi_voice_version", v);
  return v;
}

// runVoiceStage() 보다 위에!
const sid =
  new URL(location.href).searchParams.get("sid")
  || localStorage.getItem("rhythmi_session_id")
  || "";

if (!sid) {
  console.warn("[voice_test] sid is missing");
  // 필요하면 여기서 showError로 막아도 됨
}


  // ---------------------------
  // Stage 설계
  // ---------------------------
function getStagesByAge(age, version = getVoiceVersion()) {
  const isUnder14 = age < 14;

  const STAGE1_TEXT = `지금 나는 내 음성에 귀를 기울인다. 글을 소리 내어 읽을 때는 세 가지를 지킨다.
첫째, 쉼표에서는 잠깐 쉰다. 
둘째, 마침표에서는 숨을 고른다. 
셋째, 눈은 글을 따라 천천히 내려간다.

매일 저녁 나는 오늘 있었던 일들을 체크한다.
그 과정을 통해 숫자, 친숙한 단어, 가끔은 낯선 단어들이 나의 하루에 녹아있다.

09:30, 12:10, 18:45
기준, 예외, 패턴, 규칙
기쁨, 아쉬움, 안도
왜곡, 의외성, 잡념

급하게 말하지 않고, 틀려도 괜찮다.
틀린 곳 부터 다시 이어서 읽는다. 
끝까지 읽고 시간이 남으면 처음부터 다시 읽는다.`;

  const baseStage1 = {
    id: 1,
    q: "Stage 1",
    d: "위 지문을 편안하게 소리 내어 읽어주세요. 끝까지 읽지 않아도 됩니다. (Baseline 측정)",
    text: STAGE1_TEXT,
  };

  // =========================
  // v1.2
  // =========================
  if (version === "v1.2") {
    const s2 = isUnder14
  ? {
      id: 2, q: "Stage 2",
      text: "오늘 제일 중요한 일부터 순서대로 말해 주세요.",
      d: "최소 3개 이상. 1번-2번-3번처럼 번호를 붙여 말해 주세요. (각 항목은 1~2문장 정도)"
    }
  : {
      id: 2, q: "Stage 2",
      text: "오늘 처리해야 할 가장 중요한 일을 중요도 순서대로 말해 주세요.",
      d: "최소 3개 이상. 1-2-3 번호로 말해도 좋아요. (각 항목: 왜 중요한지 1문장 포함)"
    };

const s3 = isUnder14
  ? {
      id: 3, q: "Stage 3",
      text: "그 순서를 정한 기준이 있나요?",
      d: "기준을 2개 이상 말해 주세요. (예: 마감, 점수, 어려움, 기분 등) → 마지막에 한 줄로 정리"
    }
  : {
      id: 3, q: "Stage 3",
      text: "그 순서를 정할 때 쓰는 원칙/기준이 있나요?",
      d: "기준 2개 이상. (예: 마감/영향도/리스크/노력 대비 효과) → 기준마다 예시 1개씩"
    };

const s4 = isUnder14
  ? {
      id: 4, q: "Stage 4",
      text: "계획대로 못 될 때 가장 잦은 이유는 무엇인가요?",
      d: "가장 자주 생기는 방해 2가지만 말해 주세요. 그리고 다음번엔 뭘 바꿀지 1가지만 말해요."
    }
  : {
      id: 4, q: "Stage 4",
      text: "중요도대로 수행하지 못할 때 가장 잦은 원인은 무엇인가요?",
      d: "원인 2개만. (상황 → 내 반응 → 결과) 순서로 말하고, 마지막에 다음번 대안 1개를 말해 주세요."
    };

    return [baseStage1, s2, s3, s4];
  }

  // =========================
  // v1.1 (기본)
  // =========================
  const baseStage4 = {
    id: 4,
    q: "Stage 4",
    d: "",
    text: "노력을 해도 해결이 되지 않는다면 보통 어떻게 하나요?",
  };

  if (isUnder14) {
    return [
      baseStage1,
      { id: 2, q: "Stage 2", d: "게임/취미/코딩/학교 등 무엇을 파고 있고 왜 궁금한지 말해 주세요.", text: "최근 2년 안에 내가 계속 파고 있는 주제가 있다면 말해 주세요." },
      { id: 3, q: "Stage 3", d: "아직 진행 중이어도 괜찮아요.", text: "내 관심주제를 더 많이 알거나 고민을 해결하려고 내가 해본 게 있나요?" },
      baseStage4,
    ];
  }

  return [
    baseStage1,
    { id: 2, q: "Stage 2", d: "원인 → 해결방법 → 결과 순서로 짧게 설명해 주세요.", text: "내가 발견한 문제 중 해결을 위해 노력한 것이 있다면 설명해 주세요." },
    { id: 3, q: "Stage 3", d: "", text: "진행 중이라면 막히는 지점을, 완료했다면 어려웠던 지점을 설명해주세요." },
    baseStage4,
  ];
}


  // ---------------------------
  // 상태
  // ---------------------------
  const vp = new VoiceProcessor();
  let stageIdx = 0;
  let STAGES = [];

  // DEV DEBUG (콘솔 확인용)
  window.__rh = {
    get stageIdx() { return stageIdx; },
    get STAGES() { return STAGES; },
    get currStage() { return STAGES?.[stageIdx]; },
    vp,
    VoiceProcessor,
    getSid,
    apiUrl,
  };
  console.log("[DBG] __rh ready", window.__rh);

  // ---------------------------
  // 렌더
  // ---------------------------
  function renderStage() {
    const s = STAGES[stageIdx];

    if (!s) {
      const sid = getSid();
      location.href = sid ? `./done.html?sid=${encodeURIComponent(sid)}` : "./done.html";
      return;
    }

    const badge = document.getElementById("stageBadge");
    if (badge) badge.innerText = `Stage ${s.id}`;

    setQuestionText(s.text || s.q);
    setDescriptionText(s.d || "");

    setTimer(40000);
    setRecordButtonState({ recording: false, calibrating: false });

    const finishBtn = document.getElementById("finishBtn");
    if (finishBtn) finishBtn.style.display = "none";

    const recBtn = document.querySelector("#recordBtn");
    if (recBtn) recBtn.dataset.recording = "0";
  }
// ---------------------
// 녹음 품질 체크
//-------------------------

function isInAppBrowser() {
  const ua = navigator.userAgent || "";
  return /KAKAOTALK/i.test(ua) || /Instagram/i.test(ua) || /FBAN|FBAV|FB_IAB|Facebook|Messenger/i.test(ua);
}

// showErrorModal 없으면 안전하게 fallback
function showError(title, message, debug = "") {
  if (typeof window.showErrorModal === "function") {
    window.showErrorModal(title, message, debug);
  } else if (typeof window.showModal === "function") {
    window.showModal(`${title}\n\n${message}`);
  } else {
    alert(`${title}\n\n${message}`);
  }
}

// ✅ 핵심: metrics로 "분석 가능한 음성인지" 판정
function judgeVoiceQuality(metrics) {
  const snr = Number(metrics?.snr_est_db);
  const pause = Number(metrics?.pause_ratio);
  const rate = Number(metrics?.speech_rate);
  const clip = Number(metrics?.clipping_ratio);
  const pitchSd = Number(metrics?.pitch_sd);

  // 1) 마이크 입력/분석 자체가 깨진 케이스
  if (!metrics || metrics.status !== "completed") {
    return { ok: false, title: "녹음이 완료되지 않았어요", msg: "다시 시도해 주세요.", code: "not_completed" };
  }

  // 2) 라디오/환경소음/마이크 너무 멀다 → SNR 너무 낮음
  if (Number.isFinite(snr) && snr < 6) {
    return {
      ok: false,
      title: "소음이 너무 커서 분석이 어려워요",
      msg: "라디오/TV/선풍기 등 소음을 끄고, 마이크를 20~30cm로 가까이 한 뒤 다시 녹음해 주세요.",
      code: "snr_low"
    };
  }

  // 3) “말 거의 없는데도 점수 나오는” 대표 패턴: SNR 비정상적으로 큼(계산이 무너졌거나 클릭음 등)
  if (Number.isFinite(snr) && snr > 60) {
    return {
      ok: false,
      title: "음성이 제대로 감지되지 않았어요",
      msg: "말소리 대신 클릭/키보드/작은 잡음이 들어간 것 같아요. 조용한 곳에서 또박또박 말해 주세요.",
      code: "snr_invalid_high"
    };
  }

  // 4) 거의 무음/잡음인데 발화로 오인 → pause_ratio가 극단값 + rate도 비정상 조합이면 차단
  // (너 스샷에서 pause 0.009 같은 극단값이 나왔잖아)
  if (Number.isFinite(pause) && (pause < 0.01 || pause > 0.95)) {
    return {
      ok: false,
      title: "음성 입력이 불안정해요",
      msg: "마이크 거리를 확인하고(20~30cm), 주변 소음을 줄인 뒤 다시 시도해 주세요.",
      code: "pause_extreme"
    };
  }

  // 5) 클리핑(너무 크게 들어감)
  if (Number.isFinite(clip) && clip > 0.02) {
    return {
      ok: false,
      title: "소리가 너무 커서 찢어졌어요",
      msg: "마이크를 조금 멀리하거나(30~40cm), 더 작은 목소리로 다시 녹음해 주세요.",
      code: "clipping"
    };
  }

  // 6) 피치 변동이 거의 0에 가까우면(= 말이 아니라 기계음/노이즈일 가능성)
  if (Number.isFinite(pitchSd) && pitchSd > 0 && pitchSd < 5) {
    return {
      ok: false,
      title: "말소리로 판단하기 어려워요",
      msg: "라디오/기계음/잡음이 들어간 것 같아요. 조용한 곳에서 다시 녹음해 주세요.",
      code: "pitch_flat"
    };
  }

  // (선택) 발화 속도 비정상
  if (Number.isFinite(rate) && (rate < 1 || rate > 11)) {
    return {
      ok: false,
      title: "분석 값이 비정상이에요",
      msg: "입력이 불안정하게 들어갔습니다. 마이크/소음 상태를 확인 후 다시 녹음해 주세요.",
      code: "rate_outlier"
    };
  }

  return { ok: true };
}


//-----------------------------
// 소음측정중 홀딩 방지 패치 
//-----------------------------
// -------------------------
// Noise measure (failsafe)
// -------------------------
function getAudioCtx() {
  if (!window.__rh_audioCtx) {
    window.__rh_audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  return window.__rh_audioCtx;
}

async function ensureAudioRunning() {
  const ctx = getAudioCtx();
  // 모바일/브라우저에서 버튼 클릭(유저 제스처) 안에서 resume 안 하면 계속 suspended로 남는 케이스 많음
  if (ctx.state !== "running") await ctx.resume();
  return ctx;
}

function percentile(arr, p) {
  if (!arr.length) return 0;
  const a = [...arr].sort((x, y) => x - y);
  const idx = Math.max(0, Math.min(a.length - 1, Math.floor((a.length - 1) * p)));
  return a[idx];
}

/**
 * stream: getUserMedia로 받은 스트림
 * onDone: (noiseFloorRms) => { ... startRecording ... }
 */
async function measureNoiseThen(stream, onDone, opts = {}) {
  const MEASURE_MS = opts.measureMs ?? 1200;     // 소음 측정 시간
  const FAILSAFE_MS = opts.failsafeMs ?? 2500;   // 이 시간이 지나면 무조건 다음 단계로 넘어감

  const ctx = await ensureAudioRunning();

  const src = ctx.createMediaStreamSource(stream);
  const analyser = ctx.createAnalyser();
  analyser.fftSize = 2048;

  src.connect(analyser);

  const buf = new Float32Array(analyser.fftSize);
  const rmsSamples = [];

  const t0 = performance.now();
  let rafId = null;
  let done = false;

  const failsafe = setTimeout(() => {
    if (done) return;
    done = true;
    try { if (rafId) cancelAnimationFrame(rafId); } catch {}
    const floor = percentile(rmsSamples, 0.2); // 20퍼센타일(튀는 값에 덜 민감)
    console.warn("[noise] FAILSAFE -> next. ctx=", ctx.state, "samples=", rmsSamples.length, "floor=", floor);
    onDone(floor || 0);
  }, FAILSAFE_MS);

  function tick() {
    analyser.getFloatTimeDomainData(buf);

    // RMS 계산
    let sum = 0;
    for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
    const rms = Math.sqrt(sum / buf.length);

    rmsSamples.push(rms);

    const elapsed = performance.now() - t0;
    // 디버그 로그 (너무 많으면 보기 힘드니 가끔만)
    if (rmsSamples.length % 30 === 0) {
      console.log("[noise] ctx=", ctx.state, "elapsed=", Math.round(elapsed), "ms", "rms=", rms.toFixed(6));
    }

    if (elapsed >= MEASURE_MS) {
      if (done) return;
      done = true;
      clearTimeout(failsafe);
      const floor = percentile(rmsSamples, 0.2);
      console.log("[noise] DONE. ctx=", ctx.state, "samples=", rmsSamples.length, "floor=", floor);
      onDone(floor || 0);
      return;
    }

    rafId = requestAnimationFrame(tick);
  }

  tick();
}


  // ---------------------------
  // 녹음 + 전송
  // ---------------------------
 async function runVoiceStage() {
  const recBtn = document.querySelector("#recordBtn");
  const finishBtn = document.getElementById("finishBtn");

  const s = STAGES[stageIdx];
  if (!s) return;

  // ✅ sid는 try 밖에서 잡아야 catch에서도 안전하게 사용 가능
  if (!sid) {
  (window.showErrorModal || alert)(
    "세션이 없어요",
    "처음부터 다시 진행해주세요.",
    ""
  );
  location.href = "./index.html";
  return;
}

  // age_group 계산
  const age = parseInt(localStorage.getItem("rhythmi_age") || "0", 10);
  const age_group = age < 14 ? "under14" : (age < 19 ? "child" : "adult");


    // 1) 캘리브레이션

 function getVpCtx(vp) {
  return vp?.audioCtx || vp?.ctx || vp?.audioContext || null;
}

async function calibrateSilenceSafe(vp, seconds = 2, timeoutMs = 2800) {
  const ctx = getVpCtx(vp);

  // suspended면 깨우기
  if (ctx && ctx.state && ctx.state !== "running") {
    try { await ctx.resume(); } catch {}
  }

  // vp.calibrateSilence가 안 끝나면 timeout으로 강제 진행
  const calibPromise = vp.calibrateSilence(seconds);
  const timeoutPromise = new Promise((resolve) =>
    setTimeout(() => resolve({ __timeout: true }), timeoutMs)
  );

  return Promise.race([
    calibPromise
      .then((v) => ({ __timeout: false, value: v }))
      .catch((e) => ({ __timeout: true, error: e })),
    timeoutPromise
  ]);
}

try {
  // 1) 캘리브레이션 UI
  setRecordButtonState({ recording: false, calibrating: true });

  // ✅ 여기서만 캘리브레이션 1번 실행 (기존 await vp.calibrateSilence(2); 는 삭제)
  const calib = await calibrateSilenceSafe(vp, 2, 2800);
  if (calib.__timeout) {
    console.warn("[calib] timeout/failed -> continue", calib.error || "");
  }

  // 2) 녹음 시작 UI
  setRecordButtonState({ recording: true, calibrating: false });
  if (recBtn) recBtn.dataset.recording = "1";



   // 4) 녹음
    const metrics = await vp.startStage({
      durationSec: 40,
      onTick: ({ leftMs }) => setTimer(leftMs, 40),
    });

    console.log("Stage Metrics:", metrics);


    // 5) 서버 전송 payload
    const payload = {
      session_id: sid,
      stage_id: s.id,
      age_group,
      status: metrics?.status,

      recorded_ms: metrics?.recorded_ms,
      speech_rate: metrics?.speech_rate,
      pause_ratio: metrics?.pause_ratio,
      pitch_mean: metrics?.pitch_mean,
      pitch_sd: metrics?.pitch_sd,
      snr_est_db: metrics?.snr_est_db,
      clipping_ratio: metrics?.clipping_ratio,

      long_pause_count_600ms: metrics?.long_pause_count_600ms,
      short_pause_count_200_600ms: metrics?.short_pause_count_200_600ms,
      pause_ms: metrics?.pause_ms,
      restart_rms_spike_count: metrics?.restart_rms_spike_count,

      // 서버 필수 필드(임시값)
      start_latency_ms: 0,
      stop_offset_ms: metrics?.recorded_ms ?? 40000,
      jitter: 0,
      shimmer: 0,
    };

    const url = apiUrl("/submit-voice-stage");

    // ✅ submit 실패는 여기서만 처리하고 return (바깥 catch로 던지지 않음)
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

if (!res.ok) {
  const txt = await res.text().catch(() => "");
  const hint =
    res.status === 401 || res.status === 403 ? "권한/키 설정 문제일 수 있어요." :
    res.status === 404 ? "API 주소가 잘못됐거나 배포된 서버가 응답하지 않아요." :
    res.status >= 500 ? "서버 오류가 발생했어요. 잠시 후 다시 시도해 주세요." :
    "네트워크/요청 오류가 발생했어요.";

  window.showErrorModal?.(
    "서버 전송에 실패했어요",
    `녹음 데이터 전송이 실패했습니다. (${res.status}) ${hint}`,
    (txt || "").slice(0, 200)
  ) || alert("서버 전송에 실패했어요.");

  return;
}
} catch (e) {
  const name = e?.name || "Error";
  const msg =
    name === "NotAllowedError" ? "마이크 권한이 거부되었습니다. 브라우저 설정에서 마이크를 허용해 주세요." :
    name === "NotFoundError"   ? "마이크 장치를 찾지 못했습니다. 이어폰/블루투스/외부 마이크 연결을 확인해 주세요." :
    name === "NotReadableError"? "다른 앱이 마이크를 사용 중일 수 있어요. 전화/녹음/카메라 앱을 종료하고 다시 시도해 주세요." :
    "마이크 초기화에 실패했습니다. 다시 시도해 주세요.";

  window.showErrorModal?.("녹음을 시작할 수 없어요", msg, `${name}: ${e?.message || ""}`.trim())
    || alert(msg);
  return;
}


function showRetryVoiceTestModal(sid, title, message, debug = "") {
  // sid 보존(혹시 localStorage가 비었을 때 대비)
  if (sid) {
    localStorage.setItem("SESSION_ID", sid);
    localStorage.setItem("rhythmi_session_id", sid);
  }

  showErrorModal(title, message, debug);

  // ✅ 모달 OK 버튼 누르면 같은 sid로 voice_test 다시 시작(리로드/캐시버스트)
  const okBtn = document.getElementById("modalOkBtn");
  if (okBtn) {
    okBtn.onclick = () => {
      const url = new URL("voice_test.html", location.origin);
      url.searchParams.set("sid", sid);
      url.searchParams.set("retry", Date.now().toString()); // 캐시/상태 리셋용
      location.href = url.toString();
    };
  }
}

    // ✅ POST 성공 직후 진행상태 저장
    saveProgress(sid, {
      stageIdx: stageIdx + 1,
      startedAt: loadProgress(sid)?.startedAt ?? Date.now(),
    });

    // 6) 다음 stage
    stageIdx += 1;
    renderStage();

 } catch (err) {
  console.error("오류:", err);

  // 자동 로그
  try {
    await logClientError(err, { type: "outer_catch", stageIdx, sid });
  } catch (_) {}

  const name = err?.name || "Error";
  const msg = err?.message || String(err || "");

  // 인앱 브라우저 힌트(필요하면)
  const ua = navigator.userAgent || "";
  const isInApp =
    /KAKAOTALK/i.test(ua) ||
    /Instagram/i.test(ua) ||
    /FBAN|FBAV|FB_IAB|Facebook|Messenger/i.test(ua);

  showErrorModal(
    "녹음을 진행할 수 없어요",
    isInApp
      ? "인앱 브라우저에서는 마이크/업로드가 막힐 수 있어요. 외부 브라우저(크롬/사파리)로 열어 다시 시도해 주세요."
      : "녹음 중 오류가 발생했어요. 다시 시도해 주세요.",
    `${name}: ${msg}`.slice(0, 200)
  );

  setRecordButtonState({ recording: false, calibrating: false });
  if (recBtn) recBtn.dataset.recording = "0";
  try { if (typeof vp.stop === "function") vp.stop(); } catch {}


  } finally {
    // ✅ 버튼/핸들러 정리(성공/실패/return 모두 포함)
    if (finishBtn) {
      finishBtn.style.display = "none";
      finishBtn.onclick = null;
    }
    if (recBtn) recBtn.dataset.recording = "0";
  }
}

  // ---------------------------
  // 초기화
  // ---------------------------
// 3) ✅ 맨 아래에서 초기화 1번만
document.addEventListener("DOMContentLoaded", () => {
  const sid = getSid();
  const age = parseInt(localStorage.getItem("rhythmi_age") || "20", 10);

  bootstrapRun(); // ✅ stageIdx 확정(리셋/이어하기)

  const v = getVoiceVersion();
  console.log("[VOICE_VERSION]", v, sid);

  STAGES = getStagesByAge(age, v);
  renderStage();

  const recBtn = document.querySelector("#recordBtn");
  if (recBtn) {
    recBtn.addEventListener("click", () => {
      if (recBtn.dataset.recording !== "1") runVoiceStage();
    });
  }
});

</script>

<body>
    <div class="container">
        <div class="progress-container">
            <div class="progress-bar" style="width: 95%;"></div>
        </div>

        <div id="stageWrap" style="text-align: center;">
            <div id="stageBadge" class="badge" style="margin-bottom: 20px; display: inline-block;">Stage 1</div>
            <p id="desc" class="description">제시된 지문을 또박또박 읽어주세요.</p>
            <h2 id="question" class="question-title" style="text-align: center; margin-bottom: 30px;">지문 로딩 중...</h2>

         <div class="recorder-wrapper" style="position: relative; width: 200px; height: 260px; margin: 0 auto; display: flex; flex-direction: column; align-items: center;">
    
    <div style="position: relative; width: 180px; height: 180px; display: flex; align-items: center; justify-content: center;">
        <svg width="180" height="180" style="transform: rotate(-90deg); position: absolute;">
            <circle cx="90" cy="90" r="80" stroke="#333" stroke-width="4" fill="none"></circle>
            <circle id="timerLine" cx="90" cy="90" r="80" stroke="#BB86FC" stroke-width="4" fill="none" stroke-dasharray="502" stroke-dashoffset="0"></circle>
        </svg>
        <div id="timer" style="font-size: 32px; color: #BB86FC; font-weight: bold; z-index: 10;">40s</div>
    </div>
    
    <div style="width: 40px; height: 1px; background: rgba(187, 134, 252, 0.4); margin: 15px 0;"></div>

   <button id="recordBtn" style="background: none; border: none; cursor: pointer; display: flex; flex-direction: column; align-items: center; padding: 0;">
        <div id="recordCircle" style="width: 16px; height: 16px; background: #d24a4a; border-radius: 50%; margin-bottom: 8px;"></div>
        <span id="recordStatus" style="font-size: 16px; font-weight: 900; color: #fff;">녹음 시작</span>
    </button>

    <span id="calibratingText" style="margin-top: 10px; font-size: 13px; color: rgba(187, 134, 252, 0.5); visibility: hidden;">소음 측정 중...</span>
</div>

<div style="margin-top: 40px;">
    </div>
<script src="./ui-modal.js?v=1"></script>
<script src="./runtime-config.js?v=1"></script>
<script src="./session-guard.js"></script>
<script src="./report.js"></script>


    </body>
</html>
