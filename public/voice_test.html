<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css">
    <title>음성 분석</title>
</head>
<script type="module">
  import { VoiceProcessor } from "./voice-processor.js?v=2";
  import { stripSidOnNonReportPages } from "./session-guard.js";
stripSidOnNonReportPages();
  import { setQuestionText, setDescriptionText, setTimer, setRecordButtonState } from "./voice-ui.js";

  // ---------------------------
  // API helper
  // ---------------------------
const API_BASE = "https://rhythme-server-357918245340.asia-northeast3.run.app";

window.copyShareLink = async function () {
  const u = new URL(location.href);
  u.searchParams.delete("sid");
  const shareUrl = u.toString();
  try { await navigator.clipboard.writeText(shareUrl); }
  catch { prompt("복사해서 보내:", shareUrl); }
};

function apiUrl(path) {
  const base = API_BASE.endsWith("/") ? API_BASE : API_BASE + "/";
  const clean = String(path || "").replace(/^\//, "");
  return new URL(clean, base).toString();
}

// ✅ 자동 로그 수집(사용자 액션 0)
async function logClientError(err, context = {}) {
  const sid =
    new URLSearchParams(location.search).get("sid") ||
    localStorage.getItem("SESSION_ID");

  const payload = {
    session_id: sid,
    where: "voice_test",
    message: String(err?.message || err),
    name: err?.name,
    stack: err?.stack,
    ua: navigator.userAgent,
    href: location.href,
    ...context,
  };

  try {
    await fetch(apiUrl("/client-log"), {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      keepalive: true, // ✅ 모바일/인앱에서 페이지 전환 중에도 최대한 보내기
    });
  } catch (_) {
    // 실패해도 사용자 UX는 방해하지 않음
    console.warn("client-log failed", payload);
  }
}

// ✅ 전역 에러도 자동 수집
window.addEventListener("error", (e) => {
  logClientError(e.error || e.message, {
    type: "window.error",
    filename: e.filename,
    lineno: e.lineno,
    colno: e.colno,
  });
});

window.addEventListener("unhandledrejection", (e) => {
  logClientError(e.reason, { type: "unhandledrejection" });
});


  // ---------------------------
  // Session helper (단일 진실)
  // ---------------------------
function getSid() {
  const urlSid = new URLSearchParams(location.search).get("sid");
  const storeSid = localStorage.getItem("SESSION_ID");
  const winSid = window.SESSION_ID;

  const sid = urlSid || storeSid || winSid;

  if (!sid) {
    if (typeof window.showModal === "function") {
      window.showModal("세션이 없습니다. 처음부터 다시 진행해주세요.");
      setTimeout(() => location.href = "./index.html", 300);
    } else {
      alert("세션이 없습니다. 처음부터 다시 진행해주세요.");
      location.href = "./index.html";
    }
    return null;
  }

  window.SESSION_ID = sid;
  localStorage.setItem("SESSION_ID", sid);
  return sid;
}


  // ---------------------------
  // Progress (테스트 이어하기/초기화)
  // ---------------------------
  const ALLOW_RESUME = false;          // 운영모드: false 추천(항상 처음부터)
  const MAX_IDLE_MS = 15 * 60 * 1000;  // resume 허용 시, 15분 이상 비면 새로

  function progressKey(sid) { return `rh_progress_${sid}`; }
  function idleKey(sid) { return `rh_last_${sid}`; }

  function loadProgress(sid) {
    try { return JSON.parse(localStorage.getItem(progressKey(sid)) || "null"); }
    catch { return null; }
  }
  function saveProgress(sid, data) {
    localStorage.setItem(progressKey(sid), JSON.stringify(data));
    localStorage.setItem(idleKey(sid), String(Date.now()));
  }
  function clearProgress(sid) {
    localStorage.removeItem(progressKey(sid));
    localStorage.removeItem(idleKey(sid));
  }

  // ✅ 새 sid 만들지 말고 "현재 sid로 초기화"만
function resetRun(sid) {
  clearProgress(sid);
  stageIdx = 0;
  saveProgress(sid, { stageIdx: 0, startedAt: Date.now() });
  return sid;
}
  
  function bootstrapRun() {
  const sid = getSid();
  if (!sid) return null;

  if (!ALLOW_RESUME) {
    return resetRun(sid);
  }

  const last = Number(localStorage.getItem(idleKey(sid)) || "0");
  const idle = Date.now() - last;
  const p = loadProgress(sid);

  if (!p || idle > MAX_IDLE_MS) {
    return resetRun(sid);
  }

  stageIdx = p.stageIdx ?? 0;
  localStorage.setItem(idleKey(sid), String(Date.now()));
  return sid;
}

function hash32(str) {
  // 가벼운 32bit 해시 (deterministic)
  let h = 2166136261;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function getVoiceVersion() {
  // 1) 이미 배정된 버전이 있으면 그걸 고정 사용
  const saved = localStorage.getItem("rhythmi_voice_version");
  if (saved === "v1.1" || saved === "v1.2") return saved;

  // 2) 없으면 SESSION_ID로 50:50 고정 배정
  const sid = localStorage.getItem("SESSION_ID");
  if (!sid) return "v1.1"; // sid 없으면 안전하게 기본값

  const v = (hash32(sid) % 2 === 0) ? "v1.1" : "v1.2";
  localStorage.setItem("rhythmi_voice_version", v);
  return v;
}


  // ---------------------------
  // Stage 설계
  // ---------------------------
function getStagesByAge(age, version = getVoiceVersion()) {
  const isUnder14 = age < 14;

  const STAGE1_TEXT = `지금 나는 내 음성에 귀를 기울인다. 글을 소리 내어 읽을 때는 세 가지를 지킨다.
첫째, 쉼표에서는 잠깐 쉰다. 
둘째, 마침표에서는 숨을 고른다. 
셋째, 눈은 글을 따라 천천히 내려간다.

매일 저녁 나는 오늘 있었던 일들을 체크한다.
그 과정을 통해 숫자, 친숙한 단어, 가끔은 낯선 단어들이 나의 하루에 녹아있다.

09:30, 12:10, 18:45
기준, 예외, 패턴, 규칙
기쁨, 아쉬움, 안도
왜곡, 의외성, 잡념

급하게 말하지 않고, 틀려도 괜찮다.
틀린 곳 부터 다시 이어서 읽는다. 
끝까지 읽고 시간이 남으면 처음부터 다시 읽는다.`;

  const baseStage1 = {
    id: 1,
    q: "Stage 1",
    d: "위 지문을 편안하게 소리 내어 읽어주세요. 끝까지 읽지 않아도 됩니다. (Baseline 측정)",
    text: STAGE1_TEXT,
  };

  // =========================
  // v1.2
  // =========================
  if (version === "v1.2") {
    const s2 = isUnder14
  ? {
      id: 2, q: "Stage 2",
      text: "오늘 제일 중요한 일부터 순서대로 말해 주세요.",
      d: "최소 3개 이상. 1번-2번-3번처럼 번호를 붙여 말해 주세요. (각 항목은 1~2문장 정도)"
    }
  : {
      id: 2, q: "Stage 2",
      text: "오늘 처리해야 할 가장 중요한 일을 중요도 순서대로 말해 주세요.",
      d: "최소 3개 이상. 1-2-3 번호로 말해도 좋아요. (각 항목: 왜 중요한지 1문장 포함)"
    };

const s3 = isUnder14
  ? {
      id: 3, q: "Stage 3",
      text: "그 순서를 정한 기준이 있나요?",
      d: "기준을 2개 이상 말해 주세요. (예: 마감, 점수, 어려움, 기분 등) → 마지막에 한 줄로 정리"
    }
  : {
      id: 3, q: "Stage 3",
      text: "그 순서를 정할 때 쓰는 원칙/기준이 있나요?",
      d: "기준 2개 이상. (예: 마감/영향도/리스크/노력 대비 효과) → 기준마다 예시 1개씩"
    };

const s4 = isUnder14
  ? {
      id: 4, q: "Stage 4",
      text: "계획대로 못 될 때 가장 잦은 이유는 무엇인가요?",
      d: "가장 자주 생기는 방해 2가지만 말해 주세요. 그리고 다음번엔 뭘 바꿀지 1가지만 말해요."
    }
  : {
      id: 4, q: "Stage 4",
      text: "중요도대로 수행하지 못할 때 가장 잦은 원인은 무엇인가요?",
      d: "원인 2개만. (상황 → 내 반응 → 결과) 순서로 말하고, 마지막에 다음번 대안 1개를 말해 주세요."
    };

    return [baseStage1, s2, s3, s4];
  }

  // =========================
  // v1.1 (기본)
  // =========================
  const baseStage4 = {
    id: 4,
    q: "Stage 4",
    d: "",
    text: "노력을 해도 해결이 되지 않는다면 보통 어떻게 하나요?",
  };

  if (isUnder14) {
    return [
      baseStage1,
      { id: 2, q: "Stage 2", d: "게임/취미/코딩/학교 등 무엇을 파고 있고 왜 궁금한지 말해 주세요.", text: "최근 2년 안에 내가 계속 파고 있는 주제가 있다면 말해 주세요." },
      { id: 3, q: "Stage 3", d: "아직 진행 중이어도 괜찮아요.", text: "내 관심주제를 더 많이 알거나 고민을 해결하려고 내가 해본 게 있나요?" },
      baseStage4,
    ];
  }

  return [
    baseStage1,
    { id: 2, q: "Stage 2", d: "원인 → 해결방법 → 결과 순서로 짧게 설명해 주세요.", text: "내가 발견한 문제 중 해결을 위해 노력한 것이 있다면 설명해 주세요." },
    { id: 3, q: "Stage 3", d: "", text: "진행 중이라면 막히는 지점을, 완료했다면 어려웠던 지점을 설명해주세요." },
    baseStage4,
  ];
}


  // ---------------------------
  // 상태
  // ---------------------------
  const vp = new VoiceProcessor();
  let stageIdx = 0;
  let STAGES = [];

  // DEV DEBUG (콘솔 확인용)
  window.__rh = {
    get stageIdx() { return stageIdx; },
    get STAGES() { return STAGES; },
    get currStage() { return STAGES?.[stageIdx]; },
    vp,
    VoiceProcessor,
    getSid,
    apiUrl,
  };
  console.log("[DBG] __rh ready", window.__rh);

  // ---------------------------
  // 렌더
  // ---------------------------
  function renderStage() {
    const s = STAGES[stageIdx];

    if (!s) {
      const sid = getSid();
      location.href = sid ? `./done.html?sid=${encodeURIComponent(sid)}` : "./done.html";
      return;
    }

    const badge = document.getElementById("stageBadge");
    if (badge) badge.innerText = `Stage ${s.id}`;

    setQuestionText(s.text || s.q);
    setDescriptionText(s.d || "");

    setTimer(40000);
    setRecordButtonState({ recording: false, calibrating: false });

    const finishBtn = document.getElementById("finishBtn");
    if (finishBtn) finishBtn.style.display = "none";

    const recBtn = document.querySelector("#recordBtn");
    if (recBtn) recBtn.dataset.recording = "0";
  }

  // ---------------------------
  // 녹음 + 전송
  // ---------------------------
 async function runVoiceStage() {
  const recBtn = document.querySelector("#recordBtn");
  const finishBtn = document.getElementById("finishBtn");

  const s = STAGES[stageIdx];
  if (!s) return;

  // ✅ sid는 try 밖에서 잡아야 catch에서도 안전하게 사용 가능
  const sid = getSid();
  if (!sid) {
    alert("세션이 없습니다. 처음부터 다시 진행해주세요.");
    location.href = "./index.html";
    return;
  }

  // age_group 계산
  const age = parseInt(localStorage.getItem("rhythmi_age") || "0", 10);
  const age_group = age < 14 ? "under14" : (age < 19 ? "child" : "adult");

  try {
    // 1) 캘리브레이션
    setRecordButtonState({ recording: false, calibrating: true });
    await vp.calibrateSilence(2);

    // 2) 녹음 시작 UI
    setRecordButtonState({ recording: true, calibrating: false });
    if (recBtn) recBtn.dataset.recording = "1";

    // 3) 조기 종료 버튼
    if (finishBtn) {
      finishBtn.style.display = "inline-block";
      finishBtn.onclick = () => {
        try {
          if (typeof vp.stop === "function") vp.stop();
          else vp._stopped = true;
        } finally {
          finishBtn.style.display = "none";
        }
      };
    }

    // 4) 녹음
    const metrics = await vp.startStage({
      durationSec: 40,
      onTick: ({ leftMs }) => setTimer(leftMs, 40),
    });

    console.log("Stage Metrics:", metrics);

    // 5) 서버 전송 payload
    const payload = {
      session_id: sid,
      stage_id: s.id,
      age_group,
      status: metrics?.status,

      recorded_ms: metrics?.recorded_ms,
      speech_rate: metrics?.speech_rate,
      pause_ratio: metrics?.pause_ratio,
      pitch_mean: metrics?.pitch_mean,
      pitch_sd: metrics?.pitch_sd,
      snr_est_db: metrics?.snr_est_db,
      clipping_ratio: metrics?.clipping_ratio,

      long_pause_count_600ms: metrics?.long_pause_count_600ms,
      short_pause_count_200_600ms: metrics?.short_pause_count_200_600ms,
      pause_ms: metrics?.pause_ms,
      restart_rms_spike_count: metrics?.restart_rms_spike_count,

      // 서버 필수 필드(임시값)
      start_latency_ms: 0,
      stop_offset_ms: metrics?.recorded_ms ?? 40000,
      jitter: 0,
      shimmer: 0,
    };

    const url = apiUrl("/submit-voice-stage");

    // ✅ submit 실패는 여기서만 처리하고 return (바깥 catch로 던지지 않음)
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        await logClientError(new Error("submit-voice-stage not ok"), {
          type: "submit_failed",
          url,
          status: res.status,
          body: txt.slice(0, 300),
          stageIdx,
          sid,
        });
        alert("오류가 발생했습니다. 카톡에서 다시 시도해 주세요.");
        return;
      }
    } catch (err) {
      await logClientError(err, { type: "submit_exception", url, stageIdx, sid });
      alert("오류가 발생했습니다. 카톡에서 다시 시도해 주세요.");
      return;
    }

    // ✅ POST 성공 직후 진행상태 저장
    saveProgress(sid, {
      stageIdx: stageIdx + 1,
      startedAt: loadProgress(sid)?.startedAt ?? Date.now(),
    });

    // 6) 다음 stage
    stageIdx += 1;
    renderStage();

  } catch (err) {
    console.error("오류:", err);

    // ✅ 녹음/권한/MediaRecorder 등 나머지 에러 자동로그
    try {
      await logClientError(err, { type: "outer_catch", stageIdx, sid });
    } catch (_) {}

    alert("오류가 발생했습니다. 카톡에서 다시 시도해 주세요.");

    setRecordButtonState({ recording: false, calibrating: false });
    if (recBtn) recBtn.dataset.recording = "0";

  } finally {
    // ✅ 버튼/핸들러 정리(성공/실패/return 모두 포함)
    if (finishBtn) {
      finishBtn.style.display = "none";
      finishBtn.onclick = null;
    }
    if (recBtn) recBtn.dataset.recording = "0";
  }
}

  // ---------------------------
  // 초기화
  // ---------------------------
// 3) ✅ 맨 아래에서 초기화 1번만
document.addEventListener("DOMContentLoaded", () => {
  const sid = getSid();
  const age = parseInt(localStorage.getItem("rhythmi_age") || "20", 10);

  bootstrapRun(); // ✅ stageIdx 확정(리셋/이어하기)

  const v = getVoiceVersion();
  console.log("[VOICE_VERSION]", v, sid);

  STAGES = getStagesByAge(age, v);
  renderStage();

  const recBtn = document.querySelector("#recordBtn");
  if (recBtn) {
    recBtn.addEventListener("click", () => {
      if (recBtn.dataset.recording !== "1") runVoiceStage();
    });
  }
});

</script>

<body>
    <div class="container">
        <div class="progress-container">
            <div class="progress-bar" style="width: 95%;"></div>
        </div>

        <div id="stageWrap" style="text-align: center;">
            <div id="stageBadge" class="badge" style="margin-bottom: 20px; display: inline-block;">Stage 1</div>
            <p id="desc" class="description">제시된 지문을 또박또박 읽어주세요.</p>
            <h2 id="question" class="question-title" style="text-align: center; margin-bottom: 30px;">지문 로딩 중...</h2>

         <div class="recorder-wrapper" style="position: relative; width: 200px; height: 260px; margin: 0 auto; display: flex; flex-direction: column; align-items: center;">
    
    <div style="position: relative; width: 180px; height: 180px; display: flex; align-items: center; justify-content: center;">
        <svg width="180" height="180" style="transform: rotate(-90deg); position: absolute;">
            <circle cx="90" cy="90" r="80" stroke="#333" stroke-width="4" fill="none"></circle>
            <circle id="timerLine" cx="90" cy="90" r="80" stroke="#BB86FC" stroke-width="4" fill="none" stroke-dasharray="502" stroke-dashoffset="0"></circle>
        </svg>
        <div id="timer" style="font-size: 32px; color: #BB86FC; font-weight: bold; z-index: 10;">40s</div>
    </div>
    
    <div style="width: 40px; height: 1px; background: rgba(187, 134, 252, 0.4); margin: 15px 0;"></div>

   <button id="recordBtn" style="background: none; border: none; cursor: pointer; display: flex; flex-direction: column; align-items: center; padding: 0;">
        <div id="recordCircle" style="width: 16px; height: 16px; background: #d24a4a; border-radius: 50%; margin-bottom: 8px;"></div>
        <span id="recordStatus" style="font-size: 16px; font-weight: 900; color: #fff;">녹음 시작</span>
    </button>

    <span id="calibratingText" style="margin-top: 10px; font-size: 13px; color: rgba(187, 134, 252, 0.5); visibility: hidden;">소음 측정 중...</span>
</div>

<div style="margin-top: 40px;">
    </div>
<script src="./runtime-config.js?v=1"></script>
<script src="./session-guard.js"></script>
<script src="./report.js"></script>

    </body>
</html>
